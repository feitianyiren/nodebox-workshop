<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<ndbx formatVersion="0.9" type="file">
    <node name="align1" prototype="corevector.align" x="170" y="-60"/>
    <node name="copy1" prototype="corevector.copy" x="390" y="-50">
        <param name="copies">
            <value>20</value>
        </param>
        <param name="tx">
            <value>23.0</value>
        </param>
        <param name="stamp">
            <value>1</value>
        </param>
        <param name="expr">
            <value>num=int(CNUM)+1</value>
        </param>
    </node>
    <node name="datastamp1" prototype="corevector.datastamp" x="170" y="90">
        <param name="file">
            <value>csv/ppg2008.csv</value>
        </param>
    </node>
    <node name="datastamp2" prototype="corevector.datastamp" x="290" y="-50">
        <param name="_code">
            <value type="python"><![CDATA[# Data stamp generates new geometry for each row in a CSV file.
# The first row is skipped by default since we assume it is the header row.
# It copies the incoming shape geometry and provides a number of stamp keys that you can refer to.
# If you provide a template shape it will be used as a point source and for each row, the source shape will
# be translated to the point.
# The table name is appended as a prefix, so with a prefix of "data", you get the following keys:
# - data_row_count: the amount of rows in the file
# - data_column_count: the amount of columns in the file
# - data_row_index: the current index of the row, starting from zero.
# - data_row_position: the relative position in the file, from 0.0-1.0
# - data_value_0: the value of the first column. If the value can be parsed as a number, it will.
# - data_value_1: the value for the second column.
# - ....
# - data_value_n: the value for the last column (which is data_column_count - 1)
# - data_relative_value_0 -> data_relative_value_n: a value between 0.0 and 1.0,
#      the total of the column divided by the current value. This is only available if the column
#      has numbers in it.
# - column_total_0 -> column_total_n: the total value for this column. This is only available if 
#      the column has numbers in it.

import csv

from nodebox.graphics import Geometry, Transform, Point
from nodebox.node import StampExpression

def cook(self):
    if self.shape is None: return None
    geo = Geometry()
    prefix = self.tableName + "_"
    # We read in all the rows as a list.
    # We can't use "for row in reader" since we want to know the total length. 
    rows = list(csv.reader(open(self.file, "rb")))
    header_row = rows[0]
    column_count = len(header_row)
    rows = rows[1:]
    row_count = len(rows)
    
    # Go through all the rows once to calculate the total.
    sums = {}
    for row in rows:
        for i, value in enumerate(row):
            try:
                value = float(value)
                sums[i] = sums.get(i, 0) + float(value)
            except ValueError:
                pass
    for key, value in sums.items():
        context.put(prefix + 'column_total_' + str(key), value)

    # Now copy the geometry.
    context.put(prefix + 'row_count', row_count)
    context.put(prefix + 'column_count', column_count)
    
    if self.template is None:
        points = [Point()] * len(rows)
    else:
        points = self.template.points[:len(rows)]
    
    
    for row_index, pt in enumerate(points):
        row = rows[row_index]
        context.put(prefix + 'row_index', row_index)
        context.put(prefix + 'row_position', row_index/float(row_count))
        for col_index, value in enumerate(row):
            # Try to convert the value to a number. Otherwise, just output it.
            try:
                value = float(value)
                if sums.has_key(col_index):
                    relative = value / float(sums[col_index])
                    context.put(prefix + 'relative_value_' + str(col_index), relative)
            except ValueError:
                pass
            context.put(prefix + 'value_' + str(col_index), value)
        self.node.stampExpressions(context)
        t = Transform()
        t.translate(pt.x, pt.y)
        geo.extend(t.map(self.shape))
    return geo]]></value>
        </param>
        <param name="file">
            <value>csv/ppg2008.csv</value>
        </param>
    </node>
    <node name="line1" prototype="corevector.line" x="-30" y="190">
        <param name="angle">
            <value>90.0</value>
        </param>
        <param name="distance">
            <value>500.0</value>
        </param>
    </node>
    <node name="merge1" prototype="corevector.merge" rendered="true" x="470" y="100"/>
    <node name="rect1" prototype="corevector.rect" x="60" y="-60">
        <param name="_code">
            <value type="python"><![CDATA[from nodebox.graphics import Path

def cook(self):
    p = Path()
    if self.rx == 0 and self.ry == 0:
        p.rect(self.x, self.y, self.width, self.height)
    else:
        p.roundedRect(self.x, self.y, self.width, self.height, self.rx, self.ry)
    p.fillColor = self.fill
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    return p.asGeometry()]]></value>
        </param>
        <param name="width">
            <expression>20</expression>
        </param>
        <param name="height">
            <expression>5</expression>
        </param>
        <param name="fill">
            <expression>color(.5,stamp("data_relative_value_"+seed,20)*40, 0.00, 1.00)</expression>
        </param>
        <param name="seed" type="int" widget="seed">
            <expression>stamp("num",2)</expression>
        </param>
    </node>
    <node name="resample1" prototype="corevector.resample" x="60" y="190">
        <param name="length">
            <value>7.0</value>
        </param>
    </node>
    <node name="textpath1" prototype="corevector.textpath" x="60" y="80">
        <param name="_code">
            <value type="python"><![CDATA[from nodebox.graphics import Path, Text

def cook(self):
    t = Text(self.text, self.x, self.y, self.width, self.height)
    t.fontName = self.font
    t.fontSize = self.size
    # valueOf requires a correct value: LEFT, CENTER, RIGHT or JUSTIFY. Anything else will
    # make it crash. If users start doing crazy things and change the alignment, at least
    # make sure you catch the error.
    try:
        t.align = Text.Align.valueOf(self.align)
    except:
        pass
    p = t.path
    p.fillColor = self.fill
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    return p.asGeometry()]]></value>
        </param>
        <param name="text">
            <expression>stamp("data_value_0","none")</expression>
        </param>
        <param name="size">
            <value>6.0</value>
        </param>
        <param name="align">
            <value>RIGHT</value>
        </param>
        <param name="seed" type="int" widget="seed">
            <value>0</value>
        </param>
    </node>
    <conn input="datastamp1" output="textpath1" port="shape"/>
    <conn input="resample1" output="line1" port="shape"/>
    <conn input="datastamp1" output="resample1" port="template"/>
    <conn input="datastamp2" output="resample1" port="template"/>
    <conn input="copy1" output="datastamp2" port="shape"/>
    <conn input="align1" output="rect1" port="shape"/>
    <conn input="datastamp2" output="align1" port="shape"/>
    <conn input="merge1" output="copy1" port="shapes"/>
    <conn input="merge1" output="datastamp1" port="shapes"/>
</ndbx>
